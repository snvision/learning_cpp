## Обучение C++

Обучаюсь по бесплатному онлайн-учебнику [LearnCpp.com](https://www.learncpp.com/).

Обучение корирует мой наставник — [conelov](https://github.com/conelov).

Прогресс обучения: 
- [x] 1. Введение в программирование
- [x] 2. Введение в языки программирования С и С++
- [x] 3. Введение в разработку программного
обеспечения
- [x] 4. Установка IDE (Интегрированной Среды
Разработки)
- [x] 7. Конфигурация компилятора: Расширения
компилятора
- [x] 6. Режимы конфигурации «Debug» и «Release»
- [x] 7. Конфигурация компилятора: Расширения
компилятора
- [x] 8. Конфигурация компилятора: Уровни
предупреждений и ошибки
- [x] 9. Конфигурация компилятора: Выбор стандарта
языка С++
- [x] 10. Решения самых распространенных проблем
- [x] 11. Структура программ
- [x] 12. Комментарии
- [x] 13. Переменные, Инициализация и Присваивание
- [x] 14. cout, cin и endl
- [x] 15. Функции и оператор возврата return
- [x] 16. Параметры и аргументы функций
- [x] 17. Почему функции – полезны, и как их
эффективно использовать?
- [x] 18. Локальная область видимости
- [x] 19. Ключевые слова и идентификаторы
- [x] 20. Операторы
- [x] 21. Базовое форматирование кода
- [x] 22. Прототип функции и Предварительное
объявление
- [x] 23. Многофайловые программы
- [x] 24. Заголовочные файлы
- [x] 25. Директивы препроцессора
- [x] 26. Header guards и #pragma once
- [x] 28. Разработка ваших первых программ
- [x] 29. Отладка программ: степпинг и точки останова
- [x] 30. Отладка программ: стек вызовов и
отслеживание переменных
- [x] Глава №1. Итоговый тест
- [x] 31. Инициализация, присваивание и объявление
переменных
- [x] 32. Тип данных void
- [x] 33. Размер типов данных
- [x] 34. Целочисленные типы данных: short, int и long
- [x] Итоговый тест Глава №5
- [x] 35. Фиксированный размер целочисленных типов
данных
- [x] 36. Типы данных с плавающей точкой: float, double
и long double
- [x] 37. Логический тип данных bool
- [Проверка на ввод простого целого числа меньше 10](https://github.com/snvision/learning_cpp/tree/master/primeDigit)
<br></br>
- [x] 38. Символьный тип данных char
- [x] 39. Литералы и магические числа
- [x] 40. const, constexpr и символьные константы
- [x] Глава №2. Итоговый тест
- [Простой калькулятор](https://github.com/snvision/learning_cpp/tree/master/simpleCalculator)
- [Вычисление высоты мячика после x секунд падения](https://github.com/snvision/learning_cpp/tree/master/theBallfromTheTower)
<br></br>
- [x] 41. Приоритет операций и правила ассоциативности
- [x] 42. Арифметические операторы
- [Определение чётности или нечётности числа](https://github.com/snvision/learning_cpp/tree/master/oddEven)
<br></br>
- [x] 43. Инкремент, декремент и побочные эффекты
- [x] 44. Условный тернарный оператор
- [x] 45. Операторы сравнения 
- [Алгоритм для сравнения чисел с дробной частью](https://github.com/snvision/learning_cpp/tree/master/approximatelyEqualAbsRel)
<br></br>
- [x] 46. Логические операторы: И, ИЛИ, НЕ
- [x] 47. Конвертация чисел из двоичной системы в
десятичную и наоборот
- [Перевод числа из десятичной системы счисления в двоичную](https://github.com/snvision/learning_cpp/tree/master/convertFromDecToBin)
<br></br>
- [x] 48. Побитовые операторы
- [x] 49. Битовые флаги и битовые маски
- [x] Глава №3. Итоговый тест
- [x] 50. Блоки стейтментов (составные операторы)
- [x] 51. Локальные переменные, область видимости и
продолжительность жизни
- [x] 52. Глобальные переменные
- [x] 53. Почему глобальные переменные – зло?
- [x] 54. Статические переменные
- [x] 55. Связи, область видимости и продолжительность
жизни
- [x] 56. Пространства имен
- [x] 57. using-стейтменты
- [x] 58. Неявное преобразование типов данных
- [x] 59. Явное преобразование типов данных
- [x] 60. Введение в std::string
- [Cколько лет прожил человек на каждую букву из его имени и фамилии](https://github.com/snvision/learning_cpp/tree/master/howManyYears)
<br></br>
- [ ] 61. Перечисления
- [ ] 62. Классы enum
- [ ] 63. Псевдонимы типов: typedef и type alias
- [ ] 64. Структуры
- [ ] 65. Вывод типов: ключевое слово auto
- [ ] Глава №4. Итоговый тест
- [ ] 66. Операторы управления потоком выполнения
программ
- [ ] 67. Операторы условного ветвления if/else
- [ ] 68. Оператор switch
- [ ] 69. Оператор goto
- [ ] 70. Цикл while
- [ ] 71. Цикл do while
- [ ] 72. Цикл for
- [ ] 73. Операторы break и continue
- [ ] 74. Генерация случайных чисел
- [ ] 75. Обработка некорректного пользовательского
ввода
- [ ] 76. Введение в тестирование кода
- [ ] Глава №5. Итоговый тест
- [ ] 77. Массивы
- [ ] 78. Фиксированные массивы
- [ ] 79. Массивы и циклы
- [ ] 81. Многомерные массивы
- [ ] 82. Строки C-style
- [ ] 83. Введение в класс std::string_view
- [ ] 84. Указатели
- [ ] 85. Нулевые указатели
- [ ] 86. Указатели и массивы
- [ ] 87. Адресная арифметика и индексация массивов
- [ ] 88. Символьные константы строк C-style
- [ ] 89. Динамическое выделение памяти
- [ ] 90. Динамические массивы
- [ ] 91. Указатели и const
- [ ] 92. Ссылки
- [ ] 93. Ссылки и const
- [ ] 94. Оператор доступа к членам через указатель
- [ ] 95. Цикл foreach
- [ ] 96. Указатели типа void
- [ ] 97. Указатели на указатели
- [ ] 98. Введение в std::array
- [ ] 99. Введение в std::vector
- [ ] 100. Введение в итераторы
- [ ] 101. Алгоритмы в Стандартной библиотеке С++
- [ ] Глава №6. Итоговый тест
- [ ] 102. Параметры и аргументы функций
- [ ] 103. Передача по значению
- [ ] 104. Передача по ссылке
- [ ] 105. Передача по адресу
- [ ] 106. Возврат значений по ссылке, по адресу и по
значению
- [ ] 107. Встроенные функции
- [ ] 108. Перегрузка функций
- [ ] 109. Параметры по умолчанию
- [ ] 110. Указатели на функции
- [ ] 111. Стек и Куча
- [ ] 112. Ёмкость вектора
- [ ] 113. Рекурсия и Числа Фибоначчи
- [ ] 114. Обработка ошибок, cerr и exit()
- [ ] 115. assert и static_assert
- [ ] 116. Аргументы командной строки
- [ ] 117. Эллипсис
- [ ] 118. Лямбда-выражения
- [ ] 119. Лямбда-захваты
- [ ] Глава №7. Итоговый тест
- [ ] 120. Введение в ООП
- [ ] 121. Классы, Объекты и Методы
- [ ] 122. Спецификаторы доступа public и private
- [ ] 123. Инкапсуляция, Геттеры и Сеттеры
- [ ] 124. Конструкторы
- [ ] 125. Список инициализации членов класса
- [ ] 126. Инициализация нестатических членов класса
- [ ] 127. Делегирующие конструкторы
- [ ] 128. Деструкторы
- [ ] 129. Скрытый указатель *this
- [ ] 130. Классы и заголовочные файлы
- [ ] 131. Классы и const
- [ ] 132. Статические переменные-члены класса
- [ ] 133. Статические методы класса
- [ ] 134. Дружественные функции и классы
- [ ] 135. Анонимные объекты
- [ ] 136. Вложенные типы данных в классах
- [ ] 137. Измерение времени выполнения (тайминг)
кода
- [ ] Глава №8. Итоговый тест
- [ ] 138. Введение в перегрузку операторов
- [ ] 139. Перегрузка операторов через дружественные
функции
- [ ] 140. Перегрузка операторов через обычные
функции
- [ ] 141. Перегрузка операторов ввода и вывода
- [ ] 142. Перегрузка операторов через методы класса
- [ ] 143. Перегрузка унарных операторов +, - и
логического НЕ
- [ ] 144. Перегрузка операторов сравнения
- [ ] 145. Перегрузка операторов инкремента и
декремента
- [ ] 146. Перегрузка оператора индексации []
- [ ] 147. Перегрузка оператора ()
- [ ] 148. Перегрузка операций преобразования типов
данных
- [ ] 149. Конструктор копирования
- [ ] 150. Копирующая инициализация
- [ ] 151. Конструкторы преобразования, ключевые
слова explicit и delete
- [ ] 152. Перегрузка оператора присваивания
- [ ] 153. Поверхностное и глубокое копирование
- [ ] Глава №9. Итоговый тест
- [ ] 154. Типы связей между объектами
- [ ] 156. Агрегация
- [ ] 157. Ассоциация
- [ ] 158. Зависимость
- [ ] 159. Контейнерные классы
- [ ] 160. Список инициализации std::initializer_list
- [ ] Глава №10. Итоговый тест
- [ ] 161. Введение в Наследование
- [ ] 162. Базовое наследование
- [ ] 163. Порядок построения дочерних классов
- [ ] 164. Конструкторы и инициализация дочерних
классов
- [ ] 165. Наследование и спецификатор доступа
protected
- [ ] 166. Добавление нового функционала в дочерний
класс
- [ ] 167. Переопределение методов родительского
класса
- [ ] 168. Сокрытие методов родительского класса
- [ ] 169. Множественное наследование
- [ ] Глава №11. Итоговый тест
- [ ] 170. Указатели, Ссылки и Наследование
- [ ] 171. Виртуальные функции и Полиморфизм
- [ ] 172. Модификаторы override и final
- [ ] 173. Виртуальные деструкторы и Виртуальное
присваивание
- [ ] 174. Раннее и Позднее Связывания
- [ ] 175. Виртуальные таблицы
- [ ] Чистые виртуальные функции, Интерфейсы и
Абстрактные классы
- [ ] 177. Виртуальный базовый класс
- [ ] 178. Обрезка объектов
- [ ] 179. Динамическое приведение типов. Оператор
dynamic_cast
- [ ] 180. Вывод объектов классов через оператор
вывода
- [ ] Глава №12. Итоговый тест
- [ ] 181. Шаблоны функций
- [ ] 182. Экземпляры шаблонов функций
- [ ] 183. Шаблоны классов
- [ ] 184. Параметр non-type в шаблоне
- [ ] 185. Явная специализация шаблона функции
- [ ] 186. Явная специализация шаблона класса
- [ ] 187. Частичная специализация шаблона
- [ ] 188. Частичная специализация шаблонов и
Указатели
- [ ] Глава №13. Итоговый тест
- [ ] 189. Исключения. Зачем они нужны?
- [ ] 190. Обработка исключений. Операторы throw, try
и catch
- [ ] 191. Исключения, Функции и Раскручивание стека
- [ ] 192. Непойманные исключения и обработчики
catch-all
- [ ] 193. Классы-Исключения и Наследование
- [ ] 194. Повторная генерация исключений
- [ ] 195. Функциональный try-блок
- [ ] 196. Недостатки и опасности использования
исключений
- [ ] Глава No14. Итоговый тест
- [ ] 197. Умные указатели и Семантика перемещения
- [ ] 198. Ссылки r-value
- [ ] 199. Конструктор перемещения и Оператор
присваивания перемещением
- [ ] 200. Функция std::move()
- [ ] 201. Умный указатель std::unique_ptr
- [ ] 202. Умный указатель std::shared_ptr
- [ ] 203. Умный указатель std::weak_ptr
- [ ] Глава №15. Итоговый тест
- [ ] 204. Стандартная библиотека шаблонов (STL)
- [ ] 205. Контейнеры STL
- [ ] 206. Итераторы STL
- [ ] 207. Алгоритмы STL
- [ ] 208. Строковые классы std::string и std::wstring
- [ ] 209. Создание, уничтожение и конвертация
std::string
- [ ] 210. Длина и ёмкость std::string
- [ ] 211. Доступ к символам std::string. Конвертация
std::string в строки C-style
- [ ] 212. Присваивание и перестановка значений с
std::string
- [ ] 213. Добавление к std::string
- [ ] 214. Вставка символов и строк в std::string
- [ ] 215. Потоки ввода и вывода
- [ ] 216. Функционал класса istream
- [ ] 217. Функционал классов ostream и ios.
Форматирование вывода
- [ ] 218. Потоковые классы и Строки
- [ ] 219. Состояния потока и валидация
пользовательского ввода
- [ ] 220. Базовый файловый ввод и вывод
- [ ] 221. Рандомный файловый ввод и вывод
- [ ] Статические и динамические библиотеки
- [ ] Спецификации исключений и спецификатор noexcept
- [ ] Функция std::move_if_noexcept()
